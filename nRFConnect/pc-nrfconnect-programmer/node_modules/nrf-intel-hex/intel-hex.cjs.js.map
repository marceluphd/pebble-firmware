{"version":3,"file":"intel-hex.cjs.js","sources":["intel-hex.js"],"sourcesContent":["\n/**\n * Parser/writer for the \"Intel hex\" format.\n */\n\n/*\n * A regexp that matches lines in a .hex file.\n *\n * One hexadecimal character is matched by \"[0-9A-Fa-f]\".\n * Two hex characters are matched by \"[0-9A-Fa-f]{2}\"\n * Eight or more hex characters are matched by \"[0-9A-Fa-f]{8,}\"\n * A capture group of two hex characters is \"([0-9A-Fa-f]{2})\"\n *\n * Record mark         :\n * 8 or more hex chars  ([0-9A-Fa-f]{8,})\n * Checksum                              ([0-9A-Fa-f]{2})\n * Optional newline                                      (?:\\r\\n|\\r|\\n|)\n */\nconst hexLineRegexp = /:([0-9A-Fa-f]{8,})([0-9A-Fa-f]{2})(?:\\r\\n|\\r|\\n|)/g;\n\n\n// Takes a Uint8Array as input,\n// Returns an integer in the 0-255 range.\nfunction checksum(bytes) {\n    return (-bytes.reduce((sum, v)=>sum + v, 0)) & 0xFF;\n}\n\n// Takes two Uint8Arrays as input,\n// Returns an integer in the 0-255 range.\nfunction checksumTwo(array1, array2) {\n    const partial1 = array1.reduce((sum, v)=>sum + v, 0);\n    const partial2 = array2.reduce((sum, v)=>sum + v, 0);\n    return -( partial1 + partial2 ) & 0xFF;\n}\n\n\n// Trivial utility. Converts a number to hex and pads with zeroes up to 2 characters.\nfunction hexpad(number) {\n    return number.toString(16).toUpperCase().padStart(2, '0');\n}\n\n\n// Polyfill as per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\nNumber.isInteger = Number.isInteger || function(value) {\n    return typeof value === 'number' &&\n    isFinite(value) &&\n    Math.floor(value) === value;\n};\n\n\n/**\n * @class MemoryMap\n *\n * Represents the contents of a memory layout, with main focus into (possibly sparse) blocks of data.\n *<br/>\n * A {@linkcode MemoryMap} acts as a subclass of\n * {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|Map}.\n * In every entry of it, the key is the starting address of a data block (an integer number),\n * and the value is the <tt>Uint8Array</tt> with the data for that block.\n *<br/>\n * The main rationale for this is that a .hex file can contain a single block of contiguous\n * data starting at memory address 0 (and it's the common case for simple .hex files),\n * but complex files with several non-contiguous data blocks are also possible, thus\n * the need for a data structure on top of the <tt>Uint8Array</tt>s.\n *<br/>\n * In order to parse <tt>.hex</tt> files, use the {@linkcode MemoryMap.fromHex} <em>static</em> factory\n * method. In order to write <tt>.hex</tt> files, create a new {@linkcode MemoryMap} and call\n * its {@linkcode MemoryMap.asHexString} method.\n *\n * @extends Map\n * @example\n * import MemoryMap from 'nrf-intel-hex';\n *\n * let memMap1 = new MemoryMap();\n * let memMap2 = new MemoryMap([[0, new Uint8Array(1,2,3,4)]]);\n * let memMap3 = new MemoryMap({0: new Uint8Array(1,2,3,4)});\n * let memMap4 = new MemoryMap({0xCF0: new Uint8Array(1,2,3,4)});\n */\nclass MemoryMap {\n    /**\n     * @param {Iterable} blocks The initial value for the memory blocks inside this\n     * <tt>MemoryMap</tt>. All keys must be numeric, and all values must be instances of\n     * <tt>Uint8Array</tt>. Optionally it can also be a plain <tt>Object</tt> with\n     * only numeric keys.\n     */\n    constructor(blocks) {\n        this._blocks = new Map();\n\n        if (blocks && typeof blocks[Symbol.iterator] === 'function') {\n            for (const tuple of blocks) {\n                if (!(tuple instanceof Array) || tuple.length !== 2) {\n                    throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n                }\n                this.set(tuple[0], tuple[1]);\n            }\n        } else if (typeof blocks === 'object') {\n            // Try iterating through the object's keys\n            const addrs = Object.keys(blocks);\n            for (const addr of addrs) {\n                this.set(parseInt(addr), blocks[addr]);\n            }\n\n        } else if (blocks !== undefined && blocks !== null) {\n            throw new Error('First parameter to MemoryMap constructor must be an iterable of [addr, bytes] or undefined');\n        }\n    }\n\n    set(addr, value) {\n        if (!Number.isInteger(addr)) {\n            throw new Error('Address passed to MemoryMap is not an integer');\n        }\n        if (addr < 0) {\n            throw new Error('Address passed to MemoryMap is negative');\n        }\n        if (!(value instanceof Uint8Array)) {\n            throw new Error('Bytes passed to MemoryMap are not an Uint8Array');\n        }\n        return this._blocks.set(addr, value);\n    }\n    // Delegate the following to the 'this._blocks' Map:\n    get(addr)    { return this._blocks.get(addr);    }\n    clear()      { return this._blocks.clear();      }\n    delete(addr) { return this._blocks.delete(addr); }\n    entries()    { return this._blocks.entries();    }\n    forEach(callback, that) { return this._blocks.forEach(callback, that); }\n    has(addr)    { return this._blocks.has(addr);    }\n    keys()       { return this._blocks.keys();       }\n    values()     { return this._blocks.values();     }\n    get size()   { return this._blocks.size;         }\n    [Symbol.iterator]() { return this._blocks[Symbol.iterator](); }\n\n\n    /**\n     * Parses a string containing data formatted in \"Intel HEX\" format, and\n     * returns an instance of {@linkcode MemoryMap}.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * The parser has an opinionated behaviour, and will throw a descriptive error if it\n     * encounters some malformed input. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, any contiguous data block larger than that will\n     * be split in several blocks.\n     *\n     * @param {String} hexText The contents of a .hex file.\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the returned <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let intelHexString =\n     *     \":100000000102030405060708090A0B0C0D0E0F1068\\n\" +\n     *     \":00000001FF\";\n     *\n     * let memMap = MemoryMap.fromHex(intelHexString);\n     *\n     * for (let [address, dataBlock] of memMap) {\n     *     console.log('Data block at ', address, ', bytes: ', dataBlock);\n     * }\n     */\n    static fromHex(hexText, maxBlockSize = Infinity) {\n        const blocks = new MemoryMap();\n\n        let lastCharacterParsed = 0;\n        let matchResult;\n        let recordCount = 0;\n\n        // Upper Linear Base Address, the 16 most significant bits (2 bytes) of\n        // the current 32-bit (4-byte) address\n        // In practice this is a offset that is summed to the \"load offset\" of the\n        // data records\n        let ulba = 0;\n\n        hexLineRegexp.lastIndex = 0; // Reset the regexp, if not it would skip content when called twice\n\n        while ((matchResult = hexLineRegexp.exec(hexText)) !== null) {\n            recordCount++;\n\n            // By default, a regexp loop ignores gaps between matches, but\n            // we want to be aware of them.\n            if (lastCharacterParsed !== matchResult.index) {\n                throw new Error(\n                    'Malformed hex file: Could not parse between characters ' +\n                    lastCharacterParsed +\n                    ' and ' +\n                    matchResult.index +\n                    ' (\"' +\n                    hexText.substring(lastCharacterParsed, Math.min(matchResult.index, lastCharacterParsed + 16)).trim() +\n                    '\")');\n            }\n            lastCharacterParsed = hexLineRegexp.lastIndex;\n\n            // Give pretty names to the match's capture groups\n            const [, recordStr, recordChecksum] = matchResult;\n\n            // String to Uint8Array - https://stackoverflow.com/questions/43131242/how-to-convert-a-hexademical-string-of-data-to-an-arraybuffer-in-javascript\n            const recordBytes = new Uint8Array(recordStr.match(/[\\da-f]{2}/gi).map((h)=>parseInt(h, 16)));\n\n            const recordLength = recordBytes[0];\n            if (recordLength + 4 !== recordBytes.length) {\n                throw new Error('Mismatched record length at record ' + recordCount + ' (' + matchResult[0].trim() + '), expected ' + (recordLength) + ' data bytes but actual length is ' + (recordBytes.length - 4));\n            }\n\n            const cs = checksum(recordBytes);\n            if (parseInt(recordChecksum, 16) !== cs) {\n                throw new Error('Checksum failed at record ' + recordCount + ' (' + matchResult[0].trim() + '), should be ' + cs.toString(16) );\n            }\n\n            const offset = (recordBytes[1] << 8) + recordBytes[2];\n            const recordType = recordBytes[3];\n            const data = recordBytes.subarray(4);\n\n            if (recordType === 0) {\n                // Data record, contains data\n                // Create a new block, at (upper linear base address + offset)\n                if (blocks.has(ulba + offset)) {\n                    throw new Error('Duplicated data at record ' + recordCount + ' (' + matchResult[0].trim() + ')');\n                }\n                if (offset + data.length > 0x10000) {\n                    throw new Error(\n                        'Data at record ' +\n                        recordCount +\n                        ' (' +\n                        matchResult[0].trim() +\n                        ') wraps over 0xFFFF. This would trigger ambiguous behaviour. Please restructure your data so that for every record the data offset plus the data length do not exceed 0xFFFF.');\n                }\n\n                blocks.set( ulba + offset, data );\n\n            } else {\n\n                // All non-data records must have a data offset of zero\n                if (offset !== 0) {\n                    throw new Error('Record ' + recordCount + ' (' + matchResult[0].trim() + ') must have 0000 as data offset.');\n                }\n\n                switch (recordType) {\n                case 1: // EOF\n                    if (lastCharacterParsed !== hexText.length) {\n                        // This record should be at the very end of the string\n                        throw new Error('There is data after an EOF record at record ' + recordCount);\n                    }\n\n                    return blocks.join(maxBlockSize);\n\n                case 2: // Extended Segment Address Record\n                    // Sets the 16 most significant bits of the 20-bit Segment Base\n                    // Address for the subsequent data.\n                    ulba = ((data[0] << 8) + data[1]) << 4;\n                    break;\n\n                case 3: // Start Segment Address Record\n                    // Do nothing. Record type 3 only applies to 16-bit Intel CPUs,\n                    // where it should reset the program counter (CS+IP CPU registers)\n                    break;\n\n                case 4: // Extended Linear Address Record\n                    // Sets the 16 most significant (upper) bits of the 32-bit Linear Address\n                    // for the subsequent data\n                    ulba = ((data[0] << 8) + data[1]) << 16;\n                    break;\n\n                case 5: // Start Linear Address Record\n                    // Do nothing. Record type 5 only applies to 32-bit Intel CPUs,\n                    // where it should reset the program counter (EIP CPU register)\n                    // It might have meaning for other CPU architectures\n                    // (see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.faqs/ka9903.html )\n                    // but will be ignored nonetheless.\n                    break;\n                default:\n                    throw new Error('Invalid record type 0x' + hexpad(recordType) + ' at record ' + recordCount + ' (should be between 0x00 and 0x05)');\n                }\n            }\n        }\n\n        if (recordCount) {\n            throw new Error('No EOF record at end of file');\n        } else {\n            throw new Error('Malformed .hex file, could not parse any registers');\n        }\n    }\n\n\n    /**\n     * Returns a <strong>new</strong> instance of {@linkcode MemoryMap}, containing\n     * the same data, but concatenating together those memory blocks that are adjacent.\n     *<br/>\n     * The insertion order of keys in the {@linkcode MemoryMap} is guaranteed to be strictly\n     * ascending. In other words, when iterating through the {@linkcode MemoryMap}, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * If <tt>maxBlockSize</tt> is given, blocks will be concatenated together only\n     * until the joined block reaches this size in bytes. This means that the output\n     * {@linkcode MemoryMap} might have more entries than the input one.\n     *<br/>\n     * If there is any overlap between blocks, an error will be thrown.\n     *<br/>\n     * The returned {@linkcode MemoryMap} will use newly allocated memory.\n     *\n     * @param {Number} [maxBlockSize=Infinity] Maximum size of the <tt>Uint8Array</tt>s in the\n     * returned {@linkcode MemoryMap}.\n     *\n     * @return {MemoryMap}\n     */\n    join(maxBlockSize = Infinity) {\n\n        // First pass, create a Map of address→length of contiguous blocks\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        const blockSizes = new Map();\n        let lastBlockAddr = -1;\n        let lastBlockEndAddr = -1;\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const blockLength = this.get(sortedKeys[i]).length;\n\n            if (lastBlockEndAddr === blockAddr && (lastBlockEndAddr - lastBlockAddr) < maxBlockSize) {\n                // Grow when the previous end address equals the current,\n                // and we don't go over the maximum block size.\n                blockSizes.set(lastBlockAddr, blockSizes.get(lastBlockAddr) + blockLength);\n                lastBlockEndAddr += blockLength;\n            } else if (lastBlockEndAddr <= blockAddr) {\n                // Else mark a new block.\n                blockSizes.set(blockAddr, blockLength);\n                lastBlockAddr = blockAddr;\n                lastBlockEndAddr = blockAddr + blockLength;\n            } else {\n                throw new Error('Overlapping data around address 0x' + blockAddr.toString(16));\n            }\n        }\n\n        // Second pass: allocate memory for the contiguous blocks and copy data around.\n        const mergedBlocks = new MemoryMap();\n        let mergingBlock;\n        let mergingBlockAddr = -1;\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            if (blockSizes.has(blockAddr)) {\n                mergingBlock = new Uint8Array(blockSizes.get(blockAddr));\n                mergedBlocks.set(blockAddr, mergingBlock);\n                mergingBlockAddr = blockAddr;\n            }\n            mergingBlock.set(this.get(blockAddr), blockAddr - mergingBlockAddr);\n        }\n\n        return mergedBlocks;\n    }\n\n    /**\n     * Given a {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map|<tt>Map</tt>}\n     * of {@linkcode MemoryMap}s, indexed by a alphanumeric ID,\n     * returns a <tt>Map</tt> of address to tuples (<tt>Arrays</tt>s of length 2) of the form\n     * <tt>(id, Uint8Array)</tt>s.\n     *<br/>\n     * The scenario for using this is having several {@linkcode MemoryMap}s, from several calls to\n     * {@link module:nrf-intel-hex~hexToArrays|hexToArrays}, each having a different identifier.\n     * This function locates where those memory block sets overlap, and returns a <tt>Map</tt>\n     * containing addresses as keys, and arrays as values. Each array will contain 1 or more\n     * <tt>(id, Uint8Array)</tt> tuples: the identifier of the memory block set that has\n     * data in that region, and the data itself. When memory block sets overlap, there will\n     * be more than one tuple.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output are\n     * {@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray|subarrays}\n     * of the input data; new memory is <strong>not</strong> allocated for them.\n     *<br/>\n     * The insertion order of keys in the output <tt>Map</tt> is guaranteed to be strictly\n     * ascending. In other words, when iterating through the <tt>Map</tt>, the addresses\n     * will be ordered in ascending order.\n     *<br/>\n     * When two blocks overlap, the corresponding array of tuples will have the tuples ordered\n     * in the insertion order of the input <tt>Map</tt> of block sets.\n     *<br/>\n     *\n     * @param {Map.MemoryMap} memoryMaps The input memory block sets\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap1 = MemoryMap.fromHex( hexdata1 );\n     * let memMap2 = MemoryMap.fromHex( hexdata2 );\n     * let memMap3 = MemoryMap.fromHex( hexdata3 );\n     *\n     * let maps = new Map([\n     *  ['file A', blocks1],\n     *  ['file B', blocks2],\n     *  ['file C', blocks3]\n     * ]);\n     *\n     * let overlappings = MemoryMap.overlapMemoryMaps(maps);\n     *\n     * for (let [address, tuples] of overlappings) {\n     *     // if 'tuples' has length > 1, there is an overlap starting at 'address'\n     *\n     *     for (let [address, tuples] of overlappings) {\n     *         let [id, bytes] = tuple;\n     *         // 'id' in this example is either 'file A', 'file B' or 'file C'\n     *     }\n     * }\n     * @return {Map.Array<mixed,Uint8Array>} The map of possibly overlapping memory blocks\n     */\n    static overlapMemoryMaps(memoryMaps) {\n        // First pass: create a list of addresses where any block starts or ends.\n        const cuts = new Set();\n        for (const [, blocks] of memoryMaps) {\n            for (const [address, block] of blocks) {\n                cuts.add(address);\n                cuts.add(address + block.length);\n            }\n        }\n\n        const orderedCuts = Array.from(cuts.values()).sort((a,b)=>a-b);\n        const overlaps = new Map();\n\n        // Second pass: iterate through the cuts, get slices of every intersecting blockset\n        for (let i=0, l=orderedCuts.length-1; i<l; i++) {\n            const cut = orderedCuts[i];\n            const nextCut = orderedCuts[i+1];\n            const tuples = [];\n\n            for (const [setId, blocks] of memoryMaps) {\n                // Find the block with the highest address that is equal or lower to\n                // the current cut (if any)\n                const blockAddr = Array.from(blocks.keys()).reduce((acc, val)=>{\n                    if (val > cut) {\n                        return acc;\n                    }\n                    return Math.max( acc, val );\n                }, -1);\n\n                if (blockAddr !== -1) {\n                    const block = blocks.get(blockAddr);\n                    const subBlockStart = cut - blockAddr;\n                    const subBlockEnd = nextCut - blockAddr;\n\n                    if (subBlockStart < block.length) {\n                        tuples.push([ setId, block.subarray(subBlockStart, subBlockEnd) ]);\n                    }\n                }\n            }\n\n            if (tuples.length) {\n                overlaps.set(cut, tuples);\n            }\n        }\n\n        return overlaps;\n    }\n\n\n    /**\n     * Given the output of the {@linkcode MemoryMap.overlapMemoryMaps|overlapMemoryMaps}\n     * (a <tt>Map</tt> of address to an <tt>Array</tt> of <tt>(id, Uint8Array)</tt> tuples),\n     * returns a {@linkcode MemoryMap}. This discards the IDs in the process.\n     *<br/>\n     * The output <tt>Map</tt> contains as many entries as the input one (using the same addresses\n     * as keys), but the value for each entry will be the <tt>Uint8Array</tt> of the <b>last</b>\n     * tuple for each address in the input data.\n     *<br/>\n     * The scenario is wanting to join together several parsed .hex files, not worrying about\n     * their overlaps.\n     *<br/>\n     *\n     * @param {Map.Array<mixed,Uint8Array>} overlaps The (possibly overlapping) input memory blocks\n     * @return {MemoryMap} The flattened memory blocks\n     */\n    static flattenOverlaps(overlaps) {\n        return new MemoryMap(\n            Array.from(overlaps.entries()).map(([address, tuples]) => {\n                return [address, tuples[tuples.length - 1][1] ];\n            })\n        );\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, where:\n     *\n     * <ul>\n     *  <li>Each key (the start address of each <tt>Uint8Array</tt>) is a multiple of\n     *    <tt>pageSize</tt></li>\n     *  <li>The size of each <tt>Uint8Array</tt> is exactly <tt>pageSize</tt></li>\n     *  <li>Bytes from the input map to bytes in the output</li>\n     *  <li>Bytes not in the input are replaced by a padding value</li>\n     * </ul>\n     *<br/>\n     * The scenario is wanting to prepare pages of bytes for a write operation, where the write\n     * operation affects a whole page/sector at once.\n     *<br/>\n     * The insertion order of keys in the output {@linkcode MemoryMap} is guaranteed\n     * to be strictly ascending. In other words, when iterating through the\n     * {@linkcode MemoryMap}, the addresses will be ordered in ascending order.\n     *<br/>\n     * The <tt>Uint8Array</tt>s in the output will be newly allocated.\n     *<br/>\n     *\n     * @param {Number} [pageSize=1024] The size of the output pages, in bytes\n     * @param {Number} [pad=0xFF] The byte value to use for padding\n     * @return {MemoryMap}\n     */\n    paginate( pageSize=1024, pad=0xFF) {\n        if (pageSize <= 0) {\n            throw new Error('Page size must be greater than zero');\n        }\n        const outPages = new MemoryMap();\n        let page;\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            for (let pageAddr = blockAddr - (blockAddr % pageSize); pageAddr < blockEnd; pageAddr += pageSize) {\n                page = outPages.get(pageAddr);\n                if (!page) {\n                    page = new Uint8Array(pageSize);\n                    page.fill(pad);\n                    outPages.set(pageAddr, page);\n                }\n\n                const offset = pageAddr - blockAddr;\n                let subBlock;\n                if (offset <= 0) {\n                    // First page which intersects the block\n                    subBlock = block.subarray(0, Math.min(pageSize + offset, blockLength));\n                    page.set(subBlock, -offset);\n                } else {\n                    // Any other page which intersects the block\n                    subBlock = block.subarray(offset, offset + Math.min(pageSize, blockLength - offset));\n                    page.set(subBlock, 0);\n                }\n            }\n        }\n\n        return outPages;\n    }\n\n\n    /**\n     * Locates the <tt>Uint8Array</tt> which contains the given offset,\n     * and returns the four bytes held at that offset, as a 32-bit unsigned integer.\n     *\n     *<br/>\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|DataView.prototype.getUint32},\n     * except that this operates over a {@linkcode MemoryMap} instead of\n     * over an <tt>ArrayBuffer</tt>, and that this may return <tt>undefined</tt> if\n     * the address is not <em>entirely</em> contained within one of the <tt>Uint8Array</tt>s.\n     *<br/>\n     *\n     * @param {Number} offset The memory offset to read the data\n     * @param {Boolean} [littleEndian=false] Whether to fetch the 4 bytes as a little- or big-endian integer\n     * @return {Number|undefined} An unsigned 32-bit integer number\n     */\n    getUint32(offset, littleEndian) {\n        const keys = Array.from(this.keys());\n\n        for (let i=0,l=keys.length; i<l; i++) {\n            const blockAddr = keys[i];\n            const block = this.get(blockAddr);\n            const blockLength = block.length;\n            const blockEnd = blockAddr + blockLength;\n\n            if (blockAddr <= offset && (offset+4) <= blockEnd) {\n                return (new DataView(block.buffer, offset - blockAddr, 4)).getUint32(0, littleEndian);\n            }\n        }\n        return;\n    }\n\n\n    /**\n     * Returns a <tt>String</tt> of text representing a .hex file.\n     * <br/>\n     * The writer has an opinionated behaviour. Check the project's\n     * {@link https://github.com/NordicSemiconductor/nrf-intel-hex#Features|README file} for details.\n     *\n     * @param {Number} [lineSize=16] Maximum number of bytes to be encoded in each data record.\n     * Must have a value between 1 and 255, as per the specification.\n     *\n     * @return {String} String of text with the .hex representation of the input binary data\n     *\n     * @example\n     * import MemoryMap from 'nrf-intel-hex';\n     *\n     * let memMap = new MemoryMap();\n     * let bytes = new Uint8Array(....);\n     * memMap.set(0x0FF80000, bytes); // The block with 'bytes' will start at offset 0x0FF80000\n     *\n     * let string = memMap.asHexString();\n     */\n    asHexString(lineSize = 16) {\n        let lowAddress  = 0;    // 16 least significant bits of the current addr\n        let highAddress = -1 << 16; // 16 most significant bits of the current addr\n        const records = [];\n        if (lineSize <=0) {\n            throw new Error('Size of record must be greater than zero');\n        } else if (lineSize > 255) {\n            throw new Error('Size of record must be less than 256');\n        }\n\n        // Placeholders\n        const offsetRecord = new Uint8Array(6);\n        const recordHeader = new Uint8Array(4);\n\n        const sortedKeys = Array.from(this.keys()).sort((a,b)=>a-b);\n        for (let i=0,l=sortedKeys.length; i<l; i++) {\n            const blockAddr = sortedKeys[i];\n            const block = this.get(blockAddr);\n\n            // Sanity checks\n            if (!(block instanceof Uint8Array)) {\n                throw new Error('Block at offset ' + blockAddr + ' is not an Uint8Array');\n            }\n            if (blockAddr < 0) {\n                throw new Error('Block at offset ' + blockAddr + ' has a negative thus invalid address');\n            }\n            const blockSize = block.length;\n            if (!blockSize) { continue; }   // Skip zero-length blocks\n\n\n            if (blockAddr > (highAddress + 0xFFFF)) {\n                // Insert a new 0x04 record to jump to a new 64KiB block\n\n                // Round up the least significant 16 bits - no bitmasks because they trigger\n                // base-2 negative numbers, whereas subtracting the modulo maintains precision\n                highAddress = blockAddr - blockAddr % 0x10000;\n                lowAddress = 0;\n\n                offsetRecord[0] = 2;    // Length\n                offsetRecord[1] = 0;    // Load offset, high byte\n                offsetRecord[2] = 0;    // Load offset, low byte\n                offsetRecord[3] = 4;    // Record type\n                offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                records.push(\n                    ':' +\n                    Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                    hexpad(checksum(offsetRecord))\n                );\n            }\n\n            if (blockAddr < (highAddress + lowAddress)) {\n                throw new Error(\n                    'Block starting at 0x' +\n                    blockAddr.toString(16) +\n                    ' overlaps with a previous block.');\n            }\n\n            lowAddress = blockAddr % 0x10000;\n            let blockOffset = 0;\n            const blockEnd = blockAddr + blockSize;\n            if (blockEnd > 0xFFFFFFFF) {\n                throw new Error('Data cannot be over 0xFFFFFFFF');\n            }\n\n            // Loop for every 64KiB memory segment that spans this block\n            while (highAddress + lowAddress < blockEnd) {\n\n                if (lowAddress > 0xFFFF) {\n                    // Insert a new 0x04 record to jump to a new 64KiB block\n                    highAddress += 1 << 16; // Increase by one\n                    lowAddress = 0;\n\n                    offsetRecord[0] = 2;    // Length\n                    offsetRecord[1] = 0;    // Load offset, high byte\n                    offsetRecord[2] = 0;    // Load offset, low byte\n                    offsetRecord[3] = 4;    // Record type\n                    offsetRecord[4] = highAddress >> 24;    // new address offset, high byte\n                    offsetRecord[5] = highAddress >> 16;    // new address offset, low byte\n\n                    records.push(\n                        ':' +\n                        Array.prototype.map.call(offsetRecord, hexpad).join('') +\n                        hexpad(checksum(offsetRecord))\n                    );\n                }\n\n                let recordSize = -1;\n                // Loop for every record for that spans the current 64KiB memory segment\n                while (lowAddress < 0x10000 && recordSize) {\n                    recordSize = Math.min(\n                        lineSize,                            // Normal case\n                        blockEnd - highAddress - lowAddress, // End of block\n                        0x10000 - lowAddress                 // End of low addresses\n                    );\n\n                    if (recordSize) {\n\n                        recordHeader[0] = recordSize;   // Length\n                        recordHeader[1] = lowAddress >> 8;    // Load offset, high byte\n                        recordHeader[2] = lowAddress;    // Load offset, low byte\n                        recordHeader[3] = 0;    // Record type\n\n                        const subBlock = block.subarray(blockOffset, blockOffset + recordSize);   // Data bytes for this record\n\n                        records.push(\n                            ':' +\n                            Array.prototype.map.call(recordHeader, hexpad).join('') +\n                            Array.prototype.map.call(subBlock, hexpad).join('') +\n                            hexpad(checksumTwo(recordHeader, subBlock))\n                        );\n\n                        blockOffset += recordSize;\n                        lowAddress += recordSize;\n                    }\n                }\n            }\n        }\n\n        records.push(':00000001FF');    // EOF record\n\n        return records.join('\\n');\n    }\n\n\n    /**\n     * Performs a deep copy of the current {@linkcode MemoryMap}, returning a new one\n     * with exactly the same contents, but allocating new memory for each of its\n     * <tt>Uint8Array</tt>s.\n     *\n     * @return {MemoryMap}\n     */\n    clone() {\n        const cloned = new MemoryMap();\n\n        for (let [addr, value] of this) {\n            cloned.set(addr, new Uint8Array(value));\n        }\n\n        return cloned;\n    }\n\n\n    /**\n     * Given one <tt>Uint8Array</tt>, looks through its contents and returns a new\n     * {@linkcode MemoryMap}, stripping away those regions where there are only\n     * padding bytes.\n     * <br/>\n     * The start of the input <tt>Uint8Array</tt> is assumed to be offset zero for the output.\n     * <br/>\n     * The use case here is dumping memory from a working device and try to see the\n     * \"interesting\" memory regions it has. This assumes that there is a constant,\n     * predefined padding byte value being used in the \"non-interesting\" regions.\n     * In other words: this will work as long as the dump comes from a flash memory\n     * which has been previously erased (thus <tt>0xFF</tt>s for padding), or from a\n     * previously blanked HDD (thus <tt>0x00</tt>s for padding).\n     * <br/>\n     * This method uses <tt>subarray</tt> on the input data, and thus does not allocate memory\n     * for the <tt>Uint8Array</tt>s.\n     *\n     * @param {Uint8Array} bytes The input data\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @param {Number} [minPadLength=64] The minimum number of consecutive pad bytes to\n     * be considered actual padding\n     *\n     * @return {MemoryMap}\n     */\n    static fromPaddedUint8Array(bytes, padByte=0xFF, minPadLength=64) {\n\n        if (!(bytes instanceof Uint8Array)) {\n            throw new Error('Bytes passed to fromPaddedUint8Array are not an Uint8Array');\n        }\n\n        // The algorithm used is naïve and checks every byte.\n        // An obvious optimization would be to implement Boyer-Moore\n        // (see https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm )\n        // or otherwise start skipping up to minPadLength bytes when going through a non-pad\n        // byte.\n        // Anyway, we could expect a lot of cases where there is a majority of pad bytes,\n        // and the algorithm should check most of them anyway, so the perf gain is questionable.\n\n        const memMap = new MemoryMap();\n        let consecutivePads = 0;\n        let lastNonPad = -1;\n        let firstNonPad = 0;\n        let skippingBytes = false;\n        const l = bytes.length;\n\n        for (let addr = 0; addr < l; addr++) {\n            const byte = bytes[addr];\n\n            if (byte === padByte) {\n                consecutivePads++;\n                if (consecutivePads >= minPadLength) {\n                    // Edge case: ignore writing a zero-length block when skipping\n                    // bytes at the beginning of the input\n                    if (lastNonPad !== -1) {\n                        /// Add the previous block to the result memMap\n                        memMap.set(firstNonPad, bytes.subarray(firstNonPad, lastNonPad+1));\n                    }\n\n                    skippingBytes = true;\n                }\n            } else {\n                if (skippingBytes) {\n                    skippingBytes = false;\n                    firstNonPad = addr;\n                }\n                lastNonPad = addr;\n                consecutivePads = 0;\n            }\n        }\n\n        // At EOF, add the last block if not skipping bytes already (and input not empty)\n        if (!skippingBytes && lastNonPad !== -1) {\n            memMap.set(firstNonPad, bytes.subarray(firstNonPad, l));\n        }\n\n        return memMap;\n    }\n\n\n    /**\n     * Returns a new instance of {@linkcode MemoryMap}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>.\n     * Behaviour is similar to {@linkcode https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/slice|Array.prototype.slice},\n     * in that the return value is a portion of the current {@linkcode MemoryMap}.\n     *\n     * <br/>\n     * The returned {@linkcode MemoryMap} might be empty.\n     *\n     * <br/>\n     * Internally, this uses <tt>subarray</tt>, so new memory is not allocated.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @return {MemoryMap}\n     */\n    slice(address, length = Infinity){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n\n        const sliced = new MemoryMap();\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    sliced.set(sliceStart, block.subarray(relativeSliceStart, relativeSliceStart + sliceLength));\n                }\n            }\n        }\n        return sliced;\n    }\n\n    /**\n     * Returns a new instance of {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView/getUint32|Uint8Array}, containing only data between\n     * the addresses <tt>address</tt> and <tt>address + length</tt>. Any byte without a value\n     * in the input {@linkcode MemoryMap} will have a value of <tt>padByte</tt>.\n     *\n     * <br/>\n     * This method allocates new memory.\n     *\n     * @param {Number} address The start address of the slice\n     * @param {Number} length The length of memory map to slice out\n     * @param {Number} [padByte=0xFF] The value of the byte assumed to be used as padding\n     * @return {MemoryMap}\n     */\n    slicePad(address, length, padByte=0xFF){\n        if (length < 0) {\n            throw new Error('Length of the slice cannot be negative');\n        }\n        \n        const out = (new Uint8Array(length)).fill(padByte);\n\n        for (let [blockAddr, block] of this) {\n            const blockLength = block.length;\n\n            if ((blockAddr + blockLength) >= address && blockAddr < (address + length)) {\n                const sliceStart = Math.max(address, blockAddr);\n                const sliceEnd = Math.min(address + length, blockAddr + blockLength);\n                const sliceLength = sliceEnd - sliceStart;\n                const relativeSliceStart = sliceStart - blockAddr;\n\n                if (sliceLength > 0) {\n                    out.set(block.subarray(relativeSliceStart, relativeSliceStart + sliceLength), sliceStart - address);\n                }\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Checks whether the current memory map contains the one given as a parameter.\n     *\n     * <br/>\n     * \"Contains\" means that all the offsets that have a byte value in the given\n     * memory map have a value in the current memory map, and that the byte values\n     * are the same.\n     *\n     * <br/>\n     * An empty memory map is always contained in any other memory map.\n     *\n     * <br/>\n     * Returns boolean <tt>true</tt> if the memory map is contained, <tt>false</tt>\n     * otherwise.\n     *\n     * @param {MemoryMap} memMap The memory map to check\n     * @return {Boolean}\n     */\n    contains(memMap) {\n        for (let [blockAddr, block] of memMap) {\n\n            const blockLength = block.length;\n\n            const slice = this.slice(blockAddr, blockLength).join().get(blockAddr);\n\n            if ((!slice) || slice.length !== blockLength ) {\n                return false;\n            }\n\n            for (const i in block) {\n                if (block[i] !== slice[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nexport default MemoryMap;\n\n"],"names":["const","let","this","i","l","blockAddr","blocks","block"],"mappings":"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"}